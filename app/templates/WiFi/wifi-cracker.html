<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="{{ url_for('static', path='/css/styles.css') }}">
    <title>Wi-Fi Password Cracker - HackMaster Pi</title>
    <meta name="theme-color" content="#0f0f17">
</head>
<body>
    <div class="container">
        <h1>1. List Adapter</h1>
        
        <button onclick="listAdapters()">List Adapters</button>
        <div id="adapterResponse"></div>

        <h1>2. Activate Monitor Mode</h1>
        <select id="interfaceSelect">
            <option value="">-- Select an interface --</option>
        </select>
        <button onclick="activateMonitorMode()">Activate Monitor Mode</button>
        <p id="monitorStatus">The {} network interface status: </p>
         
        <h1>3. Scan Wi-Fi Networks</h1>
        <button id="scanButton" onclick="scanWifiNetworks()">Scan Wi-Fi Networks</button>
        <div id="scanResponse">
            <div id="loadingIndicator" style="display: none;">
                <p>â³ Scanning for Wi-Fi networks...</p>
            </div>
            <div id="scanResults" style="display: none;">
                <h3>Scan Results:</h3>
                <table id="networksTable" border="1">
                    <thead>
                        <tr>
                            <th>BSSID</th>
                            <th>Channel</th>
                            <th>Encryption</th>
                            <th>ESSID</th>
                        </tr>
                    </thead>
                    <tbody id="networksTableBody">
                    </tbody>
                </table>
            </div>
        </div>

        <h1>4. Set Channel for Target</h1>
        <select id="targetSelect">
            <option value="">-- Select a target --</option>
        </select>
        <button onclick="setChannel()">Set Channel</button>
        <p id="channelStatus"></p>

        <h1>5. Start Capture</h1>
        <button id="startCaptureButton" onclick="startCapture()">Start Capturing</button>
        <p id="captureStatus"></p>

        <h1>6. Send Deauth Packets</h1>
        <label for="packetCount">Number of packets:</label>
        <input type="number" id="packetCount" value="10" min="1" max="100" style="width: 80px;">
        <button id="sendDeauthButton" onclick="sendDeauthPackets()">Send Deauth Packets</button>
        <p id="deauthStatus"></p>

        <h1>7. Stop Capture</h1>
        <button id="stopCaptureButton" onclick="stopCapture()" disabled>Stop Capturing</button>
        <p id="stopCaptureStatus"></p>

        <h1>8. Check Handshakes</h1>
        <p>Check captured packets for WPA handshakes.</p>
        <button id="checkHandshakeButton" onclick="checkHandshakes()">Check Handshakes</button>
        <div id="handshakeStatus" style="margin-top: 10px; padding: 10px; background-color: #2a2a2a; border-radius: 4px;"></div>
    
        <h1>9. Password Cracking</h1>
        <p>Select a wordlist and crack the captured handshake.</p>
        <button id="loadWordlistsButton" onclick="loadWordlists()">Load Available Wordlists</button>
        <div id="wordlistSection" style="margin-top: 10px; display: none;">
            <label for="wordlistSelect">Select wordlist:</label>
            <select id="wordlistSelect">
                <option value="">-- Select a wordlist --</option>
            </select>
            <button id="crackPasswordButton" onclick="crackPassword()" style="margin-left: 10px;">Crack Password</button>
        </div>
        <div id="crackStatus" style="margin-top: 10px; padding: 10px; background-color: #2a2a2a; border-radius: 4px; display: none;"></div>
        <div id="crackResults" style="margin-top: 20px; display: none;">
            <h4>Cracking Results:</h4>
            <div id="passwordResult"></div>
        </div>
        
    </div>

    <script>
        let selectedInterface = '';
        let scannedNetworks = [];
        let selectedTarget = null;
        let targetChannel = null;
        let targetBSSID = null;
        let targetESSID = null;

        async function listAdapters() {
            try {
                const response = await fetch('/WiFi/interface/details');
                const data = await response.json();
                
                const responseDiv = document.getElementById('adapterResponse');
                
                if (data.success) {
                    responseDiv.innerHTML = `
                        <h3>Success</h3>
                        <p>Message: ${data.message}</p>
                        <h4>Output:</h4>
                        <pre>${data.output}</pre>
                    `;
                    
                    // è¼‰å…¥ç¶²å¡é¸é …
                    loadInterfaceList();
                } else {
                    responseDiv.innerHTML = `
                        <h3>Error</h3>
                        <p>Message: ${data.message}</p>
                        <pre>${data.output || ''}</pre>
                    `;
                }
            } catch (error) {
                document.getElementById('adapterResponse').innerHTML = `
                    <h3>Network Error</h3>
                    <p>${error.message}</p>
                `;
            }
        }

        async function loadInterfaceList() {
            try {
                const response = await fetch('/WiFi/interface/list');
                const data = await response.json();
                
                const select = document.getElementById('interfaceSelect');
                
                if (data.success) {
                    // æ¸…ç©ºç¾æœ‰é¸é …
                    select.innerHTML = '<option value="">-- Select an interface --</option>';
                    
                    // æ·»åŠ ç¶²å¡é¸é …
                    data.adapters.forEach(adapter => {
                        const option = document.createElement('option');
                        option.value = adapter;
                        option.textContent = adapter;
                        select.appendChild(option);
                    });
                    
                    // ç›£è½é¸æ“‡è®Šæ›´
                    select.onchange = function() {
                        selectedInterface = this.value;
                        if (selectedInterface) {
                            checkInterfaceStatus(selectedInterface);
                        }
                    };
                }
            } catch (error) {
                console.error('Error loading interfaces:', error);
            }
        }

        async function activateMonitorMode() {
            if (!selectedInterface) {
                alert('Please select an interface first');
                return;
            }

            try {
                const response = await fetch('/WiFi/interface/monitorMode', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        interface: selectedInterface
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    alert(`Monitor mode activated for ${selectedInterface}`);
                    checkInterfaceStatus(selectedInterface);
                } else {
                    alert(`Failed to activate monitor mode: ${data.message}`);
                }
            } catch (error) {
                alert(`Network error: ${error.message}`);
            }
        }

        async function checkInterfaceStatus(interfaceName) {
            try {
                const response = await fetch(`/WiFi/interface/status?interface=${interfaceName}`);
                const data = await response.json();
                
                const statusElement = document.getElementById('monitorStatus');
                
                if (data.success) {
                    statusElement.textContent = `The ${interfaceName} network interface status: ${data.status}`;
                } else {
                    statusElement.textContent = `The ${interfaceName} network interface status: Error - ${data.message}`;
                }
            } catch (error) {
                document.getElementById('monitorStatus').textContent = `The ${interfaceName} network interface status: Error - ${error.message}`;
            }
        }

        async function scanWifiNetworks() {
            if (!selectedInterface) {
                alert('Please select a network interface first');
                return;
            }

            const scanButton = document.getElementById('scanButton');
            const loadingIndicator = document.getElementById('loadingIndicator');
            const scanResults = document.getElementById('scanResults');
            
            // ç¦ç”¨æƒææŒ‰éˆ•ä¸¦é¡¯ç¤ºè¼‰å…¥æŒ‡ç¤ºå™¨
            scanButton.disabled = true;
            scanButton.textContent = 'Scanning...';
            loadingIndicator.style.display = 'block';
            scanResults.style.display = 'none';

            try {
                // è¨­å®š fetch è¶…æ™‚æ§åˆ¶å™¨
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 45000); // 45ç§’è¶…æ™‚ï¼Œçµ¦æ›´å¤šç·©è¡æ™‚é–“
                
                const response = await fetch('/WiFi/ap/scan', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        interface: selectedInterface,
                        timeout: 12  // æ¸›å°‘åˆ° 12 ç§’ï¼Œæ›´å¯¦éš›çš„æƒææ™‚é–“
                    }),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                const data = await response.json();
                
                if (data.success && data.ap_list) {
                    displayScanResults(data.ap_list);
                } else {
                    throw new Error(data.message || 'Failed to scan networks');
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    alert('Network scan timed out (45 seconds). Please try again.');
                } else {
                    alert(`Network scan failed: ${error.message}`);
                }
                scanResults.style.display = 'none';
            } finally {
                // æ¢å¾©æƒææŒ‰éˆ•
                scanButton.disabled = false;
                scanButton.textContent = 'Scan Wi-Fi Networks';
                loadingIndicator.style.display = 'none';
            }
        }

        function displayScanResults(networks) {
            const scanResults = document.getElementById('scanResults');
            const tableBody = document.getElementById('networksTableBody');
            
            // å„²å­˜æƒæçµæœ
            scannedNetworks = networks;
            
            // æ¸…ç©ºè¡¨æ ¼å…§å®¹
            tableBody.innerHTML = '';
            
            if (networks.length === 0) {
                tableBody.innerHTML = '<tr><td colspan="4">No networks found</td></tr>';
            } else {
                networks.forEach(network => {
                    const row = document.createElement('tr');
                    
                    // BSSID
                    const bssidCell = document.createElement('td');
                    bssidCell.textContent = network.BSSID || 'Unknown';
                    row.appendChild(bssidCell);
                    
                    // Channel
                    const channelCell = document.createElement('td');
                    channelCell.textContent = network.CH || 'Unknown';
                    row.appendChild(channelCell);
                    
                    // Encryption
                    const encryptionCell = document.createElement('td');
                    encryptionCell.textContent = network.ENC || 'Unknown';
                    row.appendChild(encryptionCell);
                    
                    // ESSID
                    const essidCell = document.createElement('td');
                    essidCell.textContent = network.ESSID || '<hidden>';
                    row.appendChild(essidCell);
                    
                    tableBody.appendChild(row);
                });
            }
            
            // æ›´æ–°ç›®æ¨™é¸æ“‡å™¨
            updateTargetSelect(networks);
            
            scanResults.style.display = 'block';
        }

        function updateTargetSelect(networks) {
            const targetSelect = document.getElementById('targetSelect');
            
            // æ¸…ç©ºç¾æœ‰é¸é …
            targetSelect.innerHTML = '<option value="">-- Select a target --</option>';
            
            // æ·»åŠ ç¶²è·¯é¸é …
            networks.forEach((network, index) => {
                const option = document.createElement('option');
                option.value = index;
                const essid = network.ESSID || '<hidden>';
                const bssid = network.BSSID || 'Unknown';
                option.textContent = `${essid} (${bssid})`;
                targetSelect.appendChild(option);
            });
        }

        async function setChannel() {
            const targetSelect = document.getElementById('targetSelect');
            const selectedIndex = targetSelect.value;
            
            if (!selectedIndex) {
                alert('Please select a target network first');
                return;
            }

            if (!selectedInterface) {
                alert('Please select a network interface first');
                return;
            }

            // ç²å–é¸ä¸­çš„ç›®æ¨™
            selectedTarget = scannedNetworks[selectedIndex];
            targetChannel = selectedTarget.CH;
            targetBSSID = selectedTarget.BSSID;
            targetESSID = selectedTarget.ESSID || '<hidden>';

            const channelStatus = document.getElementById('channelStatus');
            channelStatus.textContent = 'Setting channel...';

            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000); // 10ç§’è¶…æ™‚
                
                const response = await fetch('/WiFi/interface/channel', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        interface: selectedInterface,
                        channel: targetChannel
                    }),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                const data = await response.json();
                
                if (data.success) {
                    channelStatus.textContent = `Channel ${targetChannel} set for ${targetESSID}`;
                } else {
                    channelStatus.textContent = `Failed to set channel - ${data.message}`;
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    channelStatus.textContent = 'Channel setting timed out';
                } else {
                    channelStatus.textContent = `Error - ${error.message}`;
                }
            }
        }

        async function startCapture() {
            if (!selectedInterface) {
                alert('Please select a network interface first');
                return;
            }

            if (!targetBSSID || !targetChannel) {
                alert('Please select a target and set channel first');
                return;
            }

            const startButton = document.getElementById('startCaptureButton');
            const stopButton = document.getElementById('stopCaptureButton');
            const captureStatus = document.getElementById('captureStatus');

            // æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
            startButton.disabled = true;
            startButton.textContent = 'Starting...';
            captureStatus.textContent = 'Starting capture...';

            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000); // 10ç§’è¶…æ™‚
                
                const response = await fetch('/WiFi/capture/start', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        interface: selectedInterface,
                        bssid: targetBSSID,
                        channel: parseInt(targetChannel)
                    }),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                const data = await response.json();
                
                if (data.success) {
                    stopButton.disabled = false;
                    captureStatus.textContent = `Capturing traffic for ${targetESSID} on channel ${targetChannel}`;
                    startButton.textContent = 'Capture Started';
                } else {
                    startButton.disabled = false;
                    startButton.textContent = 'Start Capturing';
                    captureStatus.textContent = `Failed to start capture - ${data.message}`;
                }
            } catch (error) {
                startButton.disabled = false;
                startButton.textContent = 'Start Capturing';
                if (error.name === 'AbortError') {
                    captureStatus.textContent = 'Capture start timed out';
                } else {
                    captureStatus.textContent = `Error - ${error.message}`;
                }
            }
        }

        async function stopCapture() {
            const startButton = document.getElementById('startCaptureButton');
            const stopButton = document.getElementById('stopCaptureButton');
            const stopCaptureStatus = document.getElementById('stopCaptureStatus');

            stopButton.disabled = true;
            stopButton.textContent = 'Stopping...';
            stopCaptureStatus.textContent = 'Stopping capture...';

            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000); // 10ç§’è¶…æ™‚
                
                const response = await fetch('/WiFi/capture/stop', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                const data = await response.json();
                
                if (data.success) {
                    stopCaptureStatus.textContent = 'Capture stopped successfully';
                    stopButton.textContent = 'Capture Stopped';
                    // é‡æ–°å•Ÿç”¨ start æŒ‰éˆ•
                    startButton.disabled = false;
                    startButton.textContent = 'Start Capturing';
                } else {
                    stopCaptureStatus.textContent = `Failed to stop capture - ${data.message}`;
                    stopButton.disabled = false;
                    stopButton.textContent = 'Stop Capturing';
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    stopCaptureStatus.textContent = 'Capture stop timed out';
                } else {
                    stopCaptureStatus.textContent = `Error - ${error.message}`;
                }
                stopButton.disabled = false;
                stopButton.textContent = 'Stop Capturing';
            }
        }

        async function sendDeauthPackets() {
            if (!selectedInterface) {
                alert('Please select a network interface first');
                return;
            }

            if (!targetBSSID) {
                alert('Please select a target network first');
                return;
            }

            const deauthButton = document.getElementById('sendDeauthButton');
            const deauthStatus = document.getElementById('deauthStatus');
            const packetCount = document.getElementById('packetCount').value;

            // é©—è­‰å°åŒ…æ•¸é‡
            const packets = parseInt(packetCount);
            if (isNaN(packets) || packets < 1 || packets > 100) {
                alert('Please enter a valid packet count (1-100)');
                return;
            }

            // æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
            deauthButton.disabled = true;
            deauthButton.textContent = 'Sending...';
            deauthStatus.textContent = `Sending ${packets} deauth packets to ${targetESSID}...`;

            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 45000); // 45ç§’è¶…æ™‚
                
                const response = await fetch('/WiFi/deauth/send', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        interface: selectedInterface,
                        bssid: targetBSSID,
                        packets: packets,
                        broadcast: true
                    }),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                const data = await response.json();
                
                if (data.success) {
                    deauthStatus.textContent = `Successfully sent ${data.packets_sent} deauth packets to ${targetESSID}`;
                } else {
                    deauthStatus.textContent = `Failed to send deauth packets - ${data.message}`;
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    deauthStatus.textContent = 'Deauth sending timed out';
                } else {
                    deauthStatus.textContent = `Error - ${error.message}`;
                }
            } finally {
                // æ¢å¾©æŒ‰éˆ•ç‹€æ…‹
                deauthButton.disabled = false;
                deauthButton.textContent = 'Send Deauth Packets';
            }
        }

        async function checkHandshakes() {
            const checkButton = document.getElementById('checkHandshakeButton');
            const handshakeStatus = document.getElementById('handshakeStatus');

            // æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
            checkButton.disabled = true;
            checkButton.textContent = 'Checking...';
            handshakeStatus.textContent = 'Analyzing capture file for handshakes...';

            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 45000); // 45ç§’è¶…æ™‚
                
                const response = await fetch('/WiFi/handshake/check', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        capture_file: 'deauth_handshake-01.cap'  // ä½¿ç”¨æ–°çš„æª”åå‰ç¶´
                    }),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                const data = await response.json();
                
                if (data.success) {
                    handshakeStatus.textContent = data.message;
                } else {
                    handshakeStatus.textContent = `Failed to check handshakes - ${data.message}`;
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    handshakeStatus.textContent = 'Handshake checking timed out';
                } else {
                    handshakeStatus.textContent = `Error - ${error.message}`;
                }
            } finally {
                // æ¢å¾©æŒ‰éˆ•ç‹€æ…‹
                checkButton.disabled = false;
                checkButton.textContent = 'Check Handshakes';
            }
        }

        async function loadWordlists() {
            const loadButton = document.getElementById('loadWordlistsButton');
            const wordlistSection = document.getElementById('wordlistSection');
            const wordlistSelect = document.getElementById('wordlistSelect');

            // æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
            loadButton.disabled = true;
            loadButton.textContent = 'Loading...';

            try {
                const response = await fetch('/WiFi/wordlists/list');
                const data = await response.json();
                
                if (data.success) {
                    // æ¸…ç©ºç¾æœ‰é¸é …
                    wordlistSelect.innerHTML = '<option value="">-- Select a wordlist --</option>';
                    
                    // æŒ‰é¡åˆ¥åˆ†çµ„
                    const customWordlists = data.wordlists.filter(w => w.category === 'custom');
                    const standardWordlists = data.wordlists.filter(w => w.category === 'standard');
                    
                    // æ·»åŠ è‡ªå®šç¾©å­—å…¸
                    if (customWordlists.length > 0) {
                        const customGroup = document.createElement('optgroup');
                        customGroup.label = 'Custom Wordlists';
                        customWordlists.forEach(wordlist => {
                            const option = document.createElement('option');
                            option.value = wordlist.path;
                            const sizeKB = (wordlist.size / 1024).toFixed(2);
                            option.textContent = `${wordlist.filename} (${sizeKB} KB)`;
                            customGroup.appendChild(option);
                        });
                        wordlistSelect.appendChild(customGroup);
                    }
                    
                    // æ·»åŠ æ¨™æº–å­—å…¸
                    if (standardWordlists.length > 0) {
                        const standardGroup = document.createElement('optgroup');
                        standardGroup.label = 'Standard Wordlists';
                        standardWordlists.forEach(wordlist => {
                            const option = document.createElement('option');
                            option.value = wordlist.path;
                            const sizeKB = (wordlist.size / 1024).toFixed(2);
                            option.textContent = `${wordlist.filename} (${sizeKB} KB)`;
                            standardGroup.appendChild(option);
                        });
                        wordlistSelect.appendChild(standardGroup);
                    }
                    
                    wordlistSection.style.display = 'block';
                    loadButton.textContent = `Found ${data.count} wordlist(s)`;
                } else {
                    alert(`Failed to load wordlists: ${data.message}`);
                    loadButton.textContent = 'Load Available Wordlists';
                }
            } catch (error) {
                alert(`Error loading wordlists: ${error.message}`);
                loadButton.textContent = 'Load Available Wordlists';
            } finally {
                loadButton.disabled = false;
            }
        }

        async function crackPassword() {
            const crackButton = document.getElementById('crackPasswordButton');
            const wordlistSelect = document.getElementById('wordlistSelect');
            const crackStatus = document.getElementById('crackStatus');
            const crackResults = document.getElementById('crackResults');
            const passwordResult = document.getElementById('passwordResult');

            // æª¢æŸ¥æ˜¯å¦é¸æ“‡äº†å­—å…¸
            if (!wordlistSelect.value) {
                alert('Please select a wordlist first');
                return;
            }

            // æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
            crackButton.disabled = true;
            crackButton.textContent = 'Cracking...';
            crackStatus.style.display = 'block';
            crackStatus.textContent = 'Starting password cracking... This may take several minutes.';
            crackResults.style.display = 'none';

            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 360000); // 6åˆ†é˜è¶…æ™‚
                
                const response = await fetch('/WiFi/capture/crack', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        wordlist_file: wordlistSelect.value
                    }),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                const data = await response.json();
                
                if (data.success) {
                    crackStatus.textContent = data.message;
                    
                    if (data.password_found) {
                        passwordResult.innerHTML = `
                            <div style="padding: 15px; background-color: #d4edda; border: 1px solid #c3e6cb; border-radius: 4px; color: #155724;">
                                <h5>ğŸ‰ Password Found!</h5>
                                <p><strong>Password:</strong> <code>${data.password_found}</code></p>
                                <p><strong>Network:</strong> ${targetESSID || 'Target network'}</p>
                                <p><strong>Wordlist used:</strong> ${data.wordlist_file}</p>
                            </div>
                        `;
                    } else {
                        passwordResult.innerHTML = `
                            <div style="padding: 15px; background-color: #f8d7da; border: 1px solid #f5c6cb; border-radius: 4px; color: #721c24;">
                                <h5>âŒ Password Not Found</h5>
                                <p>The password was not found in the selected wordlist.</p>
                                <p><strong>Wordlist used:</strong> ${data.wordlist_file}</p>
                                <p>Try using a different or larger wordlist.</p>
                            </div>
                        `;
                    }
                    
                    crackResults.style.display = 'block';
                } else {
                    crackStatus.textContent = `Failed to crack password - ${data.message}`;
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    crackStatus.textContent = 'Password cracking timed out (6 minutes)';
                } else {
                    crackStatus.textContent = `Error - ${error.message}`;
                }
            } finally {
                // æ¢å¾©æŒ‰éˆ•ç‹€æ…‹
                crackButton.disabled = false;
                crackButton.textContent = 'Crack Password';
            }
        }
    </script>
</body>
</html>